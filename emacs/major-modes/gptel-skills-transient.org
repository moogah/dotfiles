#+title: GPtel Skills Transient Menu
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle gptel-skills-transient.el
#+auto_tangle: y

* Introduction

This module provides a transient menu interface for managing gptel skills,
similar to the ~gptel-tools~ transient menu. Skills can be activated for the
current gptel session via an interactive menu, providing an alternative to
the @mention-based interface.

** Features

- *Session-based activation*: Skills selected via menu persist for buffer lifetime
- *Adaptive layout*: UI adapts based on whether categories are present
  - With categories: Two-column layout (categories + skills)
  - Without categories: Single-column list of all skills
- *Backward compatible*: @mention interface continues to work alongside transient menu
- *Buffer-local scope*: Each gptel buffer has independent skill selection

** Usage

Open the skills menu with ~C-c @ s~ in a gptel buffer, or run ~M-x gptel-skills~.

- Toggle skills on/off with their assigned keys
- When categories exist, select a category to view its skills
- Press RET to confirm selection
- Press q to cancel

Selected skills are stored in buffer-local ~gptel-skills~ variable and
injected into system messages for all requests in that buffer.

* Configuration

Setup lexical binding and dependencies.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'gptel-skills)
(require 'transient)
#+end_src

* Data Structures

** Buffer-Local Variables

#+begin_src emacs-lisp
(defvar-local gptel-skills nil
  "List of skill names active in this gptel session.
Skills persist for the lifetime of the buffer.

Example: (\"writing-elisp\" \"emacs-elisp-debugging\")")
#+end_src

* Helper Functions

** Build Structure

Analyze the registry to determine if categories exist and build appropriate structure.

#+begin_src emacs-lisp
(defun jf/gptel-skills--build-structure ()
  "Build structure from jf/gptel-skills--registry.

Returns plist with:
  :has-categories - t if any skill has :category property
  :data - Either nested alist (with categories) or flat list (without)

With categories, data format:
  ((\"Category1\" . (\"skill1\" \"skill2\"))
   (\"Category2\" . (\"skill3\"))
   (nil . (\"uncategorized-skill\")))

Without categories, data format:
  (\"skill1\" \"skill2\" \"skill3\")"
  (let ((has-categories nil)
        (categorized-skills (make-hash-table :test 'equal))
        (all-skills '()))

    ;; First pass: check for categories and collect skills
    (maphash
     (lambda (skill-name metadata)
       (let ((category (plist-get metadata :category)))
         (when category
           (setq has-categories t))
         (push skill-name all-skills)
         ;; Group by category (nil for uncategorized)
         (let ((skills-list (gethash category categorized-skills)))
           (puthash category
                    (cons skill-name skills-list)
                    categorized-skills))))
     jf/gptel-skills--registry)

    ;; Build appropriate structure
    (if has-categories
        ;; With categories: return nested alist
        (let ((categories-alist '()))
          (maphash
           (lambda (category skills)
             (push (cons category (nreverse skills)) categories-alist))
           categorized-skills)
          (list :has-categories t
                :data (nreverse categories-alist)))
      ;; Without categories: return flat list
      (list :has-categories nil
            :data (sort all-skills #'string<)))))
#+end_src

** Initialize Value

Initialize the transient switch value based on current buffer-local ~gptel-skills~.

#+begin_src emacs-lisp
(defun jf/gptel-skills--init-value (skill-name)
  "Return initial value for SKILL-NAME switch.
Returns non-nil if SKILL-NAME is in buffer-local gptel-skills list."
  (and gptel-skills
       (member skill-name gptel-skills)))
#+end_src

** Get Skill Description

Get the description for a skill from the registry.

#+begin_src emacs-lisp
(defun jf/gptel-skills--get-description (skill-name)
  "Get description for SKILL-NAME from registry.
Returns description string or empty string if not found."
  (let ((metadata (gethash skill-name jf/gptel-skills--registry)))
    (if metadata
        (or (plist-get metadata :description) "")
      "")))
#+end_src

* Custom Transient Classes

** Skill Switch Class

Class for toggling individual skills. Works for both categorized and uncategorized views.

#+begin_src emacs-lisp
(defclass jf/gptel-skills--switch (transient-switch)
  ((skill-name :initarg :skill-name))
  "Class for transient switches that toggle individual skills.")

(cl-defmethod transient-infix-set ((obj jf/gptel-skills--switch) value)
  "Set VALUE of a skill switch OBJ.
Adds or removes the skill from the :skills list in transient scope."
  (let* ((state (transient-scope))
         (skill-name (oref obj skill-name))
         (skills (plist-get state :skills)))
    (if value
        (progn
          ;; Add skill to list if not present
          (cl-pushnew skill-name skills :test #'equal)
          (plist-put state :skills skills)
          (oset obj value skill-name))
      ;; Remove skill from list
      (plist-put state :skills (delete skill-name skills))
      (oset obj value nil))
    (oset transient--prefix scope state)))
#+end_src

** Category Switch Class

Class for toggling skill categories. Only instantiated when categories are present.

#+begin_src emacs-lisp
(defclass jf/gptel-skills--switch-category (transient-switch)
  ((category :initarg :category))
  "Class for transient switches that toggle entire skill categories.
Their own value is ignored - they control visibility and bulk selection.")

(cl-defmethod transient-format-value ((obj jf/gptel-skills--switch-category))
  "Format the value display for category OBJ showing (active/total) count."
  (let* ((category (oref obj category))
         (structure (jf/gptel-skills--build-structure))
         (categories-data (plist-get structure :data))
         (category-skills (cdr (assoc category categories-data)))
         (active-skills (plist-get (transient-scope) :skills))
         (active-count (cl-count-if
                        (lambda (skill) (member skill active-skills))
                        category-skills))
         (total-count (length category-skills)))
    (if (> active-count 0)
        (propertize (format "(%d/%d)" active-count total-count)
                    'face 'transient-value)
      (propertize (format "(0/%d)" total-count)
                  'face 'transient-inactive-value))))

(cl-defmethod transient-infix-read ((obj jf/gptel-skills--switch-category))
  "Determine OBJ value according to category toggle settings.
Three-state logic:
- If category not active: return current value (to activate it)
- If category active and skills selected: return nil (to deselect all)
- If category active and no skills selected: return argument (to select all)"
  (let* ((category (oref obj category))
         (active (equal category (plist-get (transient-scope) :category)))
         (structure (jf/gptel-skills--build-structure))
         (categories-data (plist-get structure :data))
         (category-skills (cdr (assoc category categories-data)))
         (active-skills (plist-get (transient-scope) :skills))
         (selected (cl-some (lambda (skill) (member skill active-skills))
                            category-skills)))
    (if (not active)
        (oref obj value)
      (if selected nil (oref obj argument)))))

(cl-defmethod transient-infix-set ((obj jf/gptel-skills--switch-category) value)
  "When setting VALUE, toggle all skills in the category of OBJ."
  (let* ((category (oref obj category))
         (structure (jf/gptel-skills--build-structure))
         (categories-data (plist-get structure :data))
         (category-skills (cdr (assoc category categories-data))))
    ;; Find all skill switches with this category and toggle them
    (dolist (suffix-obj transient--suffixes)
      (when (and (cl-typep suffix-obj 'jf/gptel-skills--switch)
                 (member (oref suffix-obj skill-name) category-skills))
        (if value
            (transient-infix-set suffix-obj (oref suffix-obj skill-name))
          (transient-infix-set suffix-obj nil))))
    ;; Update the active category in scope
    (plist-put (transient-scope) :category category)
    (plist-put (transient-scope) :key (oref obj key))
    ;; Set the "value" of the category itself
    (oset obj value value)))
#+end_src

* Transient Menu Definition

** Main Menu Command

The ~gptel-skills~ transient prefix provides an adaptive menu for managing skills.
Layout adapts based on whether categories exist in the registry.

#+begin_src emacs-lisp
;;;###autoload
(transient-define-prefix gptel-skills ()
  "Select skills to include with gptel requests in this buffer.

Skills persist for the lifetime of the gptel buffer session.
You can also use @mention syntax as an alternative interface.

When categories are defined, skills are organized by category.
Without categories, all skills appear in a single list."
  :refresh-suffixes t
  [:description "Select skills for this gptel session"
   [""
    ;; Show count of active skills
    (:info (lambda ()
             (let ((count (length (plist-get (transient-scope) :skills))))
               (if (> count 0)
                   (propertize (format "%d skill%s active"
                                      count
                                      (if (= count 1) "" "s"))
                               'face 'transient-value)
                 (propertize "No skills active"
                             'face 'transient-inactive-value))))
           :format " %d")]
   [""
    ("RET" "Confirm selection"
     (lambda ()
       (interactive)
       (let ((selected-skills (plist-get (transient-scope 'gptel-skills) :skills)))
         (setq gptel-skills selected-skills)
         (message "Activated %d skill%s for this buffer"
                  (length selected-skills)
                  (if (= (length selected-skills) 1) "" "s"))))
     :transient transient--do-return)
    ("q" "Cancel" transient-quit-one)]]
  ;; Dynamic layout based on whether categories exist
  [[:class transient-column
    :setup-children
    (lambda (_)
      (let* ((structure (jf/gptel-skills--build-structure))
             (has-categories (plist-get structure :has-categories))
             (data (plist-get structure :data)))
        (if has-categories
            ;; Two-column layout: categories
            (transient-parse-suffixes
             'gptel-skills
             (cl-loop
              for (category . skills) in data
              with unused-keys = (nconc (number-sequence ?a ?z)
                                        (number-sequence ?0 ?9))
              for category-key = (seq-first unused-keys)
              do (setq unused-keys (cdr unused-keys))
              collect (list (key-description (list category-key))
                           (concat (propertize (or category "Uncategorized")
                                              'face 'transient-heading)
                                   (make-string (max (- 20 (length (or category "Uncategorized"))) 0) ? ))
                           (char-to-string category-key)
                           :format " %k %d %v"
                           :class 'jf/gptel-skills--switch-category
                           :category category)
              into categories
              finally do (plist-put (transient-scope) :keys unused-keys)
              finally return categories))
          ;; Single-column layout: all skills
          (transient-parse-suffixes
           'gptel-skills
           (when data
             (cl-loop
              for skill-name in data
              with unused-keys = (nconc (number-sequence ?a ?z)
                                        (number-sequence ?0 ?9))
              for skill-key = (seq-first unused-keys)
              do (setq unused-keys (cdr unused-keys))
              collect (list (key-description (list skill-key))
                           (concat (propertize skill-name 'face 'bold)
                                   (make-string (max (- 25 (length skill-name)) 0) ? )
                                   (propertize
                                    (concat "(" (jf/gptel-skills--get-description skill-name) ")")
                                    'face 'shadow))
                           skill-name
                           :format " %k %d"
                           :init-value (lambda (obj)
                                        (oset obj value
                                              (jf/gptel-skills--init-value
                                               (oref obj skill-name))))
                           :class 'jf/gptel-skills--switch
                           :skill-name skill-name)))))))]
   [:class transient-column
    :setup-children
    (lambda (_)
      ;; Second column: skills for selected category (only when categories exist)
      (let* ((structure (jf/gptel-skills--build-structure))
             (has-categories (plist-get structure :has-categories)))
        (when has-categories
          (transient-parse-suffixes
           'gptel-skills
           (when-let* ((category (plist-get (transient-scope) :category))
                      (skill-keys (plist-get (transient-scope) :keys))
                      (data (plist-get structure :data))
                      (category-skills (cdr (assoc category data))))
             (cl-loop
              for skill-name in category-skills
              for skill-key = (seq-first skill-keys)
              do (setq skill-keys (cdr skill-keys))
              collect (list (key-description (list skill-key))
                           (concat (make-string (max (- 25 (length skill-name)) 0) ? )
                                   (propertize
                                    (concat "(" (jf/gptel-skills--get-description skill-name) ")")
                                    'face 'shadow))
                           skill-name
                           :format " %k %v %d"
                           :init-value (lambda (obj)
                                        (oset obj value
                                              (jf/gptel-skills--init-value
                                               (oref obj skill-name))))
                           :class 'jf/gptel-skills--switch
                           :skill-name skill-name)
              into infixes-for-category
              finally return
              (cons (list :info
                         (lambda ()
                           (concat
                            (propertize (plist-get (transient-scope) :key)
                                       'face 'transient-key)
                            (propertize " toggle all" 'face 'transient-heading)))
                         :format " %d")
                    infixes-for-category)))))))]]
  (interactive)
  (unless (hash-table-p jf/gptel-skills--registry)
    (user-error "Skills registry not initialized. Run M-x jf/gptel-skills-reload"))
  (when (= (hash-table-count jf/gptel-skills--registry) 0)
    (user-error "No skills found. Check your skills directory"))
  (transient-setup
   'gptel-skills nil nil
   :scope (list :skills (copy-sequence gptel-skills))))
#+end_src

* Keybinding Integration

Add keybinding to make the skills menu easily accessible from gptel buffers.

#+begin_src emacs-lisp
;; Add keybinding to gptel-mode-map
(with-eval-after-load 'gptel
  (when (boundp 'gptel-mode-map)
    (define-key gptel-mode-map (kbd "C-c @ s") 'gptel-skills)))
#+end_src

* Provide Feature

#+begin_src emacs-lisp
(provide 'gptel-skills-transient)
#+end_src
