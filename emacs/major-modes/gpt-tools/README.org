#+title: GPTEL Tools Guide
#+author: Jeff Farr

* Introduction

This directory contains custom tools for gptel that can be used by LLMs to interact with
your Emacs environment. Tools are defined using =gptel-make-tool= and organized by category.

* What are GPTEL Tools?

GPTEL tools are elisp functions with metadata that LLMs can call to extend their capabilities.
When an LLM decides to use a tool, it provides arguments, gptel runs the function in Emacs,
and optionally returns the result to the LLM.

Tools enable LLMs to:
- Read and write files
- Execute commands
- Query databases
- Search the web
- Interact with Emacs buffers
- Control your Emacs environment

* Tool Definition Structure

** Required Parameters

Every tool requires these four parameters:

- =:name= :: Tool name in snake_case (e.g., "read_file", "create_buffer")
- =:function= :: The elisp function (lambda or symbol) that runs
- =:description= :: Verbose description of what the tool does, how to call it, and what it returns
- =:args= :: List of argument specifications (or nil for no arguments)

** Argument Specification

Each argument in =:args= is a plist with required keys:

- =:name= :: Argument name as a string
- =:type= :: Type as a symbol: =string=, =number=, =integer=, =boolean=, =array=, =object=, or =null=
- =:description= :: Description of what the argument represents

** Optional Parameters

*** For Arguments:
- =:optional= :: Boolean indicating if argument is optional
- =:enum= :: Vector of strings for enumerated types (e.g., =["read" "write" "append"]=)
- =:items= :: For =array= type, plist with at least =:type= of items
- =:properties= :: For =object= type, plist serializable to JSON object spec

*** For Tools:
- =:category= :: String for grouping in UI (default: "misc")
- =:async= :: Boolean for async functions (see Async Tools section)
- =:confirm= :: Boolean or function to prompt user before running
- =:include= :: Whether to include tool results in LLM output (useful for chat buffers)

* Basic Examples

** Simple Tool with One Argument

#+begin_src emacs-lisp
(gptel-make-tool
 :name "read_buffer"
 :function (lambda (buffer)
             (unless (buffer-live-p (get-buffer buffer))
               (error "Buffer %s is not live" buffer))
             (with-current-buffer buffer
               (buffer-substring-no-properties (point-min) (point-max))))
 :description "Return the contents of an Emacs buffer"
 :args (list '(:name "buffer"
               :type string
               :description "The name of the buffer to read"))
 :category "emacs")
#+end_src

** Tool with Multiple Arguments

#+begin_src emacs-lisp
(gptel-make-tool
 :name "create_file"
 :function (lambda (path filename content)
             (let ((full-path (expand-file-name filename path)))
               (with-temp-buffer
                 (insert content)
                 (write-file full-path))
               (format "Created file %s in %s" filename path)))
 :description "Create a new file with specified content"
 :args (list '(:name "path"
               :type string
               :description "Directory where to create the file")
             '(:name "filename"
               :type string
               :description "Name of the file to create")
             '(:name "content"
               :type string
               :description "Content to write to the file"))
 :category "filesystem")
#+end_src

* Advanced Examples

** Tool with Optional Arguments

#+begin_src emacs-lisp
(gptel-make-tool
 :name "search_files"
 :function (lambda (pattern &optional directory case-sensitive)
             (let ((default-directory (or directory default-directory)))
               ;; Search implementation
               ))
 :description "Search for pattern in files"
 :args (list '(:name "pattern"
               :type string
               :description "Pattern to search for")
             '(:name "directory"
               :type string
               :optional t
               :description "Directory to search in (defaults to current)")
             '(:name "case_sensitive"
               :type boolean
               :optional t
               :description "Whether search is case-sensitive"))
 :category "search")
#+end_src

** Tool with Enum Arguments

#+begin_src emacs-lisp
(gptel-make-tool
 :name "open_file"
 :function (lambda (filepath mode)
             (let ((buf (find-file-noselect filepath)))
               (pcase mode
                 ("read" (view-buffer buf))
                 ("edit" (switch-to-buffer buf))
                 ("split" (switch-to-buffer-other-window buf)))
               (format "Opened %s in %s mode" filepath mode)))
 :description "Open a file in Emacs with specified display mode"
 :args (list '(:name "filepath"
               :type string
               :description "Full path to the file")
             '(:name "mode"
               :type string
               :enum ["read" "edit" "split"]
               :description "How to display the file"))
 :category "emacs")
#+end_src

** Tool with Array Arguments

#+begin_src emacs-lisp
(gptel-make-tool
 :name "delete_files"
 :function (lambda (filepaths)
             (mapconcat
              (lambda (path)
                (if (file-exists-p path)
                    (progn (delete-file path)
                           (format "Deleted: %s" path))
                  (format "Not found: %s" path)))
              filepaths
              "\n"))
 :description "Delete multiple files"
 :args (list '(:name "filepaths"
               :type array
               :items (:type string)
               :description "Array of file paths to delete"))
 :category "filesystem")
#+end_src

** Tool with Confirmation

#+begin_src emacs-lisp
(gptel-make-tool
 :name "execute_command"
 :function (lambda (command)
             (shell-command-to-string command))
 :description "Execute a shell command and return output"
 :args (list '(:name "command"
               :type string
               :description "Shell command to execute"))
 :category "system"
 :confirm t  ; Always prompt user before running
 :include t) ; Include results in LLM output
#+end_src

* Async Tools

For long-running operations, mark the tool as =:async t=. The function should:
1. Take a callback as its FIRST argument (not included in =:args=)
2. Call the callback with the result when ready

#+begin_src emacs-lisp
(gptel-make-tool
 :name "fetch_url"
 :function (lambda (callback url)  ; callback is first arg
             (url-retrieve
              url
              (lambda (status)
                (if (plist-get status :error)
                    (funcall callback (format "Error: %s" (plist-get status :error)))
                  (goto-char (point-min))
                  (re-search-forward "\n\n")
                  (funcall callback (buffer-substring (point) (point-max)))))))
 :description "Fetch content from a URL asynchronously"
 :args (list '(:name "url"
               :type string
               :description "URL to fetch"))
 :category "network"
 :async t)  ; Mark as async
#+end_src

* Subagent Tools

** Overview

Subagent tools enable LLM agents to delegate specialized tasks to isolated subagents
running in their own contexts with dedicated tool sets and configurations. This allows
complex tasks to be broken down into focused subtasks handled by specialized agents.

** Architecture

Subagents run in visible buffers with complete state isolation:

- *FSM Isolation*: Each subagent gets its own =gptel-fsm= instance
- *Buffer-Local State*: Separate tools, backend, model, and system message
- *Async Execution*: Subagents stream results back via callbacks
- *Profile-Based*: Reusable configurations defined with =gptel-make-preset=
- *Visible Buffers*: Named =*gptel-subagent-PROFILE-TIMESTAMP*= for easy inspection

** Available Subagent Profiles

*** explore-agent

Read-only code exploration and semantic analysis agent.

*Tools*:
- Filesystem: =read_file=, =list_directory=
- Projectile: =list_known_projects=, =get_project_info=, =list_project_files=
- Ggtags: =find_definition=, =find_references=, =find_symbol=
- Web: =web_search=, =read_url=

*Use Cases*:
- Analyzing code structure and organization
- Understanding implementations and architectures
- Tracing dependencies and data flow
- Gathering information about unfamiliar codebases

*** plan-agent

Planning and requirements gathering agent with delegation capability.

*Tools*:
- Delegation: =invoke_subagent= (can invoke explore-agent)
- Basic: =read_file=, =list_directory=

*Use Cases*:
- Developing implementation plans
- Gathering requirements through dialog
- Breaking down complex tasks
- Coordinating multiple exploration tasks

** Usage Example

Primary agent delegates to subagent:

#+begin_src emacs-lisp
;; LLM calls this tool
invoke_subagent(
  agent_profile="explore-agent",
  task_description="Analyze the authentication system in /path/to/project. Identify key functions, security patterns, and data flow.",
  context_files=["/path/to/project/auth.el", "/path/to/project/session.el"]
)
#+end_src

The subagent will:
1. Run in isolated context with read-only tools
2. Read specified files
3. Navigate code structure
4. Use semantic tools as needed
5. Return final analysis summary

** Nested Delegation

Plan agent can invoke explore agent for code investigation:

#+begin_example
Primary Agent
  └─> plan-agent: "Develop implementation plan for feature X"
       └─> explore-agent: "Analyze existing authentication patterns"
       └─> explore-agent: "Find all database access points"
#+end_example

*Depth Limit*: Maximum delegation depth is 3 levels (configurable via =jf/gptel-max-delegation-depth=)

** Dialog Coordination

When plan-agent needs user input, it includes questions in its result. The primary
agent should forward these questions to you.

Example result from plan-agent:

#+begin_example
=== Subagent Result ===
Agent: plan-agent
Task: Develop authentication plan

Based on exploration, I've identified two approaches:

1. Token-based (JWT) - stateless, scalable
2. Session-based - simpler, server-managed state

Questions for user:
- Do you need mobile client support? (JWT recommended)
- What's your expected user scale? (<1000 users: sessions fine, >10k: JWT better)
- Do you have Redis/Memcached available? (needed for distributed sessions)

Once I know your answers, I can finalize the implementation plan.
=== End Subagent Result ===
#+end_example

** Result Format

Subagents return final responses only (not full conversation history). Results are
formatted with clear delimiters:

- Agent profile name
- Task description
- Final response/summary

This keeps context manageable while providing the primary agent with actionable information.

** Security

- Subagent invocation requires confirmation (=:confirm t=)
- Explore agent has read-only tools only
- Recursion prevented via depth tracking
- Subagent buffers remain open for inspection (kill manually when done)

** Configuration

Subagent profiles are defined in =subagent-tools.org= using =gptel-make-preset=:

#+begin_src emacs-lisp
(gptel-make-preset 'explore-agent
  :description "Read-only code exploration"
  :backend "Claude"
  :model 'claude-3-7-sonnet-20250219
  :system "You are an exploration agent..."
  :tools '("read_file" "list_directory" ...)
  :temperature 0.5)
#+end_src

To add new subagent types:
1. Define profile with =gptel-make-preset=
2. Add to =invoke_subagent= tool's =:enum= list
3. Document expected behavior

* Organization

Tools are organized by category in separate files:

- =filesystem-tools.org= :: File and directory operations
- =projectile-tools.org= :: Project-aware navigation and file discovery
- =ggtags-tools.org= :: Semantic code navigation using GNU Global
- =org-roam-tools.org= :: Knowledge management and note operations
- =meta-tools.org= :: Tools for generating new tools
- =subagent-tools.org= :: Delegation to specialized subagents
- =community-tools.org= :: External tool packages (gptel-agent, ragmacs, etc.)

Each =.org= file tangles to a =.el= file that is loaded by =major-modes/gpt.org=.

* Using Tools

** Selecting Tools

Tools can be selected from gptel's transient menu (=M-x gptel-menu=):
1. Navigate to the tools section
2. Select which tools to enable (globally or buffer-locally)
3. Configure confirmation and result inclusion settings

** Setting Tools via Elisp

#+begin_src emacs-lisp
;; Set tools globally
(setq gptel-tools (list tool1 tool2 tool3))

;; Set tools for current buffer only
(setq-local gptel-tools (list tool1 tool2))
#+end_src

** Tools in Presets

Include tools in gptel presets for specific workflows:

#+begin_src emacs-lisp
(gptel-make-preset 'coding-assistant
  :description "Assistant with file and buffer access"
  :tools (list read_buffer create_file list_directory))
#+end_src

* Resources

** Official Documentation
- [[https://github.com/karthink/gptel][gptel README]]
- [[https://github.com/karthink/gptel/wiki/Tools-collection][gptel Wiki - Tool Collection]]

** Community Tool Collections
- [[https://github.com/skissue/llm-tool-collection][llm-tool-collection]] - Files, buffers, system commands
- [[https://github.com/karthink/gptel-agent][gptel-agent]] - Agentic tools: filesystem, bash, web search
- [[https://github.com/ultronozm/codel.el][codel.el]] - Code editing tools
- [[https://codeberg.org/bajsicki/gptel-org-tools][gptel-org-tools]] - Org file interaction
- [[https://github.com/positron-solutions/ragmacs][ragmacs]] - Emacs introspection

* Tips

1. *Descriptive names*: Use clear, descriptive snake_case names
2. *Detailed descriptions*: LLMs rely on descriptions to understand when and how to use tools
3. *Error handling*: Always handle errors gracefully and return informative messages
4. *Security*: Use =:confirm t= for dangerous operations (file deletion, command execution)
5. *Return values*: Return strings that are useful as context for the LLM's next response
6. *Categories*: Group related tools with consistent category names
7. *Testing*: Test tools manually before relying on LLM to call them correctly
