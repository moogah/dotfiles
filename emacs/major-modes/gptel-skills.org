#+title: GPTel Skills System (@Mention-Based)
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle gptel-skills.el
#+auto_tangle: y

* Introduction

This module implements a dynamic skills system for gptel that allows explicit skill
activation via =@skill-name= mentions during conversations. Skills are Claude Code skills
from =~/.claude/skills/= that provide context, guidelines, and reference material.

** Architecture Overview

Skills work through explicit mention and dynamic injection:

1. **Discovery** (initialization): Scan skills directory, parse metadata with lazy loading
2. **Mention Detection** (typing): Detect =@skill-name= syntax, add visual overlays
3. **Dynamic Injection** (sending): Hook into =gptel-prompt-transform-functions=, inject based on mode
4. **Progressive Disclosure** (optional): Auto-load referenced resources

** Key Features

- **Explicit activation**: Type =@skill-name= in gptel buffer
- **Visual feedback**: Overlays show active skills (like @mentions)
- **Smart injection**: Content goes to system message, context, or user message
- **Lazy loading**: Skills load on first mention, then cached
- **Completion support**: TAB completion for skill names

** Usage Example

#+begin_example
User types in gptel buffer:
"Help me write elisp @writing-elisp"
                       ^^^^^^^^^^^^^^ <- overlay appears

User sends (C-c RET):
→ Skill content injected as system message
→ @mention stripped from prompt
→ LLM receives prompt with skill guidance
#+end_example

* Configuration

Setup lexical binding and dependencies.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
(require 'gptel nil t)
#+end_src

** Customization Variables

#+begin_src emacs-lisp
(defgroup gptel-skills nil
  "Skills system for gptel with @mention activation."
  :group 'gptel
  :prefix "jf/gptel-skills-")

(defcustom jf/gptel-skills-directory "~/.claude/skills"
  "Directory containing Claude Code skills.
Skills should be organized as SKILL-NAME/SKILL.md."
  :type 'directory
  :group 'gptel-skills)

(defcustom jf/gptel-skills-mention-prefix "@"
  "Prefix character for skill mentions in buffer."
  :type 'string
  :group 'gptel-skills)

(defcustom jf/gptel-skills-strip-mentions t
  "Whether to strip @mentions from prompt before sending.
If nil, mentions are kept in the prompt (visible to LLM)."
  :type 'boolean
  :group 'gptel-skills)

(defcustom jf/gptel-skills-auto-expand nil
  "Automatically load referenced resources without prompting."
  :type 'boolean
  :group 'gptel-skills)

(defcustom jf/gptel-skills-verbose nil
  "When non-nil, print verbose messages during skill operations."
  :type 'boolean
  :group 'gptel-skills)
#+end_src

** Face Definitions

#+begin_src emacs-lisp
(defface jf/gptel-skills-mention-face
  '((t :inherit font-lock-keyword-face :underline t))
  "Face for @skill mentions in gptel buffers.")
#+end_src

* Data Structures

#+begin_src emacs-lisp
(defvar jf/gptel-skills--registry (make-hash-table :test 'equal)
  "Hash table mapping skill names to metadata plists.

Each entry is a plist with keys:
  :name          - Skill name (string)
  :description   - Description for completion/help (string)
  :path          - Full path to SKILL.md file (string)
  :dir           - Skill directory path (string)
  :injection-mode - Where to inject: system|context|user|auto (symbol)
  :loaded        - Whether content has been loaded (boolean)
  :content       - Cached skill content (string or nil)")

(defvar-local jf/gptel-skills--active nil
  "List of skill names active in current buffer via @mentions.")

(defvar-local jf/gptel-skills--overlays nil
  "List of skill mention overlays in current buffer.")
#+end_src

* Discovery and Parsing (Phase 1)

** Discover Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills--discover ()
  "Scan skills directory and return list of SKILL.md file paths.
Returns list of absolute paths to SKILL.md files."
  (let ((skills-dir (expand-file-name jf/gptel-skills-directory)))
    (when (file-directory-p skills-dir)
      (let ((skill-files '()))
        (dolist (entry (directory-files skills-dir t "^[^.]" t))
          (when (file-directory-p entry)
            (let ((skill-file (expand-file-name "SKILL.md" entry)))
              (when (file-exists-p skill-file)
                (push skill-file skill-files)))))
        (nreverse skill-files)))))
#+end_src

** Parse Metadata

#+begin_src emacs-lisp
(defun jf/gptel-skills--parse-metadata (skill-path)
  "Parse YAML frontmatter from SKILL.md at SKILL-PATH.
Returns plist with :name, :description, :injection-mode, :path, :dir.
Returns nil if parsing fails."
  (condition-case err
      (with-temp-buffer
        (insert-file-contents skill-path)
        (goto-char (point-min))

        ;; Check for YAML frontmatter delimiter
        (if (not (looking-at "^---[ \t]*$"))
            (progn
              (when jf/gptel-skills-verbose
                (message "Warning: No YAML frontmatter in %s" skill-path))
              nil)

          ;; Parse YAML frontmatter
          (forward-line 1)
          (let ((yaml-start (point))
                (yaml-end nil)
                (metadata '()))

            ;; Find end of frontmatter
            (when (re-search-forward "^---[ \t]*$" nil t)
              (setq yaml-end (match-beginning 0))

              ;; Parse name
              (goto-char yaml-start)
              (when (re-search-forward "^name:[ \t]+\\(.+\\)$" yaml-end t)
                (setq metadata (plist-put metadata :name (string-trim (match-string 1)))))

              ;; Parse description
              (goto-char yaml-start)
              (when (re-search-forward "^description:[ \t]+\\(.+\\)$" yaml-end t)
                (setq metadata (plist-put metadata :description (string-trim (match-string 1)))))

              ;; Parse injection-mode
              (goto-char yaml-start)
              (when (re-search-forward "^injection-mode:[ \t]+\\(system\\|context\\|user\\|auto\\)$" yaml-end t)
                (setq metadata (plist-put metadata :injection-mode (intern (match-string 1)))))

              ;; Add path and directory
              (setq metadata (plist-put metadata :path skill-path))
              (setq metadata (plist-put metadata :dir (file-name-directory skill-path)))

              ;; Set defaults
              (unless (plist-get metadata :name)
                (setq metadata (plist-put metadata :name
                                          (file-name-base (directory-file-name
                                                          (file-name-directory skill-path))))))
              (unless (plist-get metadata :description)
                (setq metadata (plist-put metadata :description
                                          (plist-get metadata :name))))
              (unless (plist-get metadata :injection-mode)
                (setq metadata (plist-put metadata :injection-mode 'auto)))

              ;; Initialize loading state
              (setq metadata (plist-put metadata :loaded nil))
              (setq metadata (plist-put metadata :content nil))

              metadata))))
    (error
     (message "Error parsing skill metadata from %s: %s" skill-path (error-message-string err))
     nil)))
#+end_src

** Parse Content

#+begin_src emacs-lisp
(defun jf/gptel-skills--parse-content (skill-path)
  "Read full SKILL.md content from SKILL-PATH, excluding YAML frontmatter.
Returns content as string, or nil on error."
  (condition-case err
      (with-temp-buffer
        (insert-file-contents skill-path)
        (goto-char (point-min))

        ;; Skip YAML frontmatter if present
        (when (looking-at "^---[ \t]*$")
          (forward-line 1)
          (when (re-search-forward "^---[ \t]*$" nil t)
            (forward-line 1)))

        ;; Return rest of buffer
        (buffer-substring-no-properties (point) (point-max)))
    (error
     (message "Error reading skill content from %s: %s" skill-path (error-message-string err))
     nil)))
#+end_src

** Load Resource

#+begin_src emacs-lisp
(defun jf/gptel-skills--load-resource (skill-dir resource-file)
  "Load additional resource file from SKILL-DIR.
RESOURCE-FILE is relative filename (e.g., 'REFERENCE.md').
Returns content as string, or nil if file doesn't exist."
  (let ((resource-path (expand-file-name resource-file skill-dir)))
    (when (file-exists-p resource-path)
      (condition-case err
          (with-temp-buffer
            (insert-file-contents resource-path)
            (buffer-string))
        (error
         (message "Error loading resource %s: %s" resource-path (error-message-string err))
         nil)))))
#+end_src

* Mention Detection and Visual Feedback (Phase 2)

** Detect Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills--detect-mentions (&optional buffer)
  "Scan BUFFER for @skill-name patterns.
Returns list of (skill-name . position) tuples for valid skills.
If BUFFER is nil, uses current buffer."
  (with-current-buffer (or buffer (current-buffer))
    (let ((mentions '())
          (prefix (regexp-quote jf/gptel-skills-mention-prefix))
          (skill-names (hash-table-keys jf/gptel-skills--registry)))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
          (let ((skill-name (match-string 1))
                (pos (match-beginning 0)))
            ;; Only include if skill exists in registry
            (when (member skill-name skill-names)
              (push (cons skill-name pos) mentions)))))
      (nreverse mentions))))
#+end_src

** Add Overlay

#+begin_src emacs-lisp
(defun jf/gptel-skills--add-overlay (beg end skill-name)
  "Create overlay marking @mention from BEG to END for SKILL-NAME."
  (let* ((metadata (gethash skill-name jf/gptel-skills--registry))
         (description (plist-get metadata :description))
         (ov (make-overlay beg end nil t nil)))
    (overlay-put ov 'face 'jf/gptel-skills-mention-face)
    (overlay-put ov 'gptel-skill skill-name)
    (overlay-put ov 'help-echo description)
    (overlay-put ov 'evaporate t)
    (overlay-put ov 'priority 100)
    (push ov jf/gptel-skills--overlays)
    ov))
#+end_src

** Update Overlays

#+begin_src emacs-lisp
(defun jf/gptel-skills--update-overlays (&optional _beg _end _len)
  "Update overlays and active skills list based on current @mentions.
Designed to be called from after-change-functions."
  (when (and (derived-mode-p 'gptel-mode)
             (hash-table-p jf/gptel-skills--registry)
             (> (hash-table-count jf/gptel-skills--registry) 0))
    ;; Remove all existing overlays
    (mapc #'delete-overlay jf/gptel-skills--overlays)
    (setq jf/gptel-skills--overlays nil)

    ;; Detect current mentions
    (let* ((mentions (jf/gptel-skills--detect-mentions))
           (skill-names (mapcar #'car mentions)))

      ;; Create overlays for each mention
      (dolist (mention mentions)
        (let* ((skill-name (car mention))
               (pos (cdr mention))
               (end-pos (+ pos (length jf/gptel-skills-mention-prefix)
                          (length skill-name))))
          (jf/gptel-skills--add-overlay pos end-pos skill-name)))

      ;; Update active skills list
      (setq jf/gptel-skills--active (delete-dups skill-names)))))
#+end_src

** Completion at Point

#+begin_src emacs-lisp
(defun jf/gptel-skills--completion-at-point ()
  "Provide completion for @skill mentions.
Integrates with completion-at-point-functions."
  (when (and (derived-mode-p 'gptel-mode)
             (> (hash-table-count jf/gptel-skills--registry) 0))
    (let* ((prefix (regexp-quote jf/gptel-skills-mention-prefix))
           (bounds (bounds-of-thing-at-point 'symbol))
           (start (and bounds (car bounds)))
           (end (and bounds (cdr bounds))))
      ;; Check if we're after @ prefix
      (when (and start
                 (> start (point-min))
                 (string= (buffer-substring-no-properties (1- start) start)
                          jf/gptel-skills-mention-prefix))
        (list (1- start)  ; include the @
              end
              (mapcar (lambda (name)
                       (concat jf/gptel-skills-mention-prefix name))
                     (hash-table-keys jf/gptel-skills--registry))
              :exclusive 'no
              :annotation-function
              (lambda (candidate)
                (let* ((skill-name (substring candidate (length jf/gptel-skills-mention-prefix)))
                       (metadata (gethash skill-name jf/gptel-skills--registry))
                       (mode (plist-get metadata :injection-mode)))
                  (format " (%s)" mode))))))))
#+end_src

* Dynamic Injection (Phase 3)

** Transform Inject

#+begin_src emacs-lisp
(defun jf/gptel-skills--transform-inject (fsm)
  "Main prompt transform function for injecting skills.
Detects @mentions, loads content, determines injection mode, and injects.
Added to gptel-prompt-transform-functions. FSM is the state machine."
  (when (and (> (hash-table-count jf/gptel-skills--registry) 0)
             jf/gptel-skills--active)
    ;; Detect mentions in current prompt buffer
    (let ((mentions (jf/gptel-skills--detect-mentions)))
      (when mentions
        (dolist (mention mentions)
          (let* ((skill-name (car mention))
                 (metadata (gethash skill-name jf/gptel-skills--registry)))
            (when metadata
              ;; Load content if not already loaded
              (unless (plist-get metadata :loaded)
                (let ((content (jf/gptel-skills--parse-content (plist-get metadata :path))))
                  (when content
                    (plist-put metadata :loaded t)
                    (plist-put metadata :content content)
                    (puthash skill-name metadata jf/gptel-skills--registry))))

              ;; Get content and determine injection mode
              (let* ((content (plist-get metadata :content))
                     (mode-specified (plist-get metadata :injection-mode))
                     (mode (if (eq mode-specified 'auto)
                              (jf/gptel-skills--determine-injection-mode metadata content)
                            mode-specified)))

                (when (and content mode)
                  (when jf/gptel-skills-verbose
                    (message "Injecting skill: %s (mode: %s)" skill-name mode))

                  ;; Inject based on mode
                  (jf/gptel-skills--inject-content content mode skill-name))))))

        ;; Strip @mentions if configured
        (when jf/gptel-skills-strip-mentions
          (jf/gptel-skills--strip-mentions))))))
#+end_src

** Determine Injection Mode

#+begin_src emacs-lisp
(defun jf/gptel-skills--determine-injection-mode (metadata content)
  "Analyze CONTENT and determine best injection mode.
Returns symbol: system, context, or user."
  ;; Simple heuristic analysis
  (cond
   ;; Behavioral guidelines → system
   ((string-match-p "^\\(You are\\|When \\|Always \\|Never \\)" content)
    'system)

   ;; Has code blocks, tables, references → context
   ((or (string-match-p "```" content)
        (string-match-p "^|.*|$" content)
        (> (length content) 1000))
    'context)

   ;; Has numbered steps, immediate instructions → user
   ((string-match-p "^[0-9]+\\." content)
    'user)

   ;; Default: system (behavioral guidance)
   (t 'system)))
#+end_src

** Inject Content

#+begin_src emacs-lisp
(defun jf/gptel-skills--inject-content (content mode skill-name)
  "Inject CONTENT based on MODE for SKILL-NAME.
MODE is symbol: system, context, or user."
  (pcase mode
    ('system
     ;; Append to system message
     (setq-local gptel--system-message
                (if gptel--system-message
                    (concat gptel--system-message
                            (format "\n\n## Skill: %s\n\n" skill-name)
                            content)
                  (concat (format "## Skill: %s\n\n" skill-name)
                          content))))

    ('context
     ;; Add to gptel-context as a buffer-like source
     (let ((temp-buf (generate-new-buffer (format " *gptel-skill-%s*" skill-name))))
       (with-current-buffer temp-buf
         (insert (format "# Skill: %s\n\n" skill-name))
         (insert content))
       ;; Add to context list
       (setq-local gptel-context
                  (append gptel-context (list temp-buf)))))

    ('user
     ;; Insert directly in prompt buffer at beginning
     (save-excursion
       (goto-char (point-min))
       (insert (format "## Reference: %s\n\n" skill-name))
       (insert content)
       (insert "\n\n---\n\n")))))
#+end_src

** Strip Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills--strip-mentions ()
  "Remove or hide @mentions from prompt buffer.
Uses invisible text property to hide mentions."
  (save-excursion
    (goto-char (point-min))
    (let ((prefix (regexp-quote jf/gptel-skills-mention-prefix)))
      (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
        (let ((skill-name (match-string 1)))
          ;; Only strip if skill is in registry
          (when (gethash skill-name jf/gptel-skills--registry)
            ;; Make invisible
            (put-text-property (match-beginning 0) (match-end 0)
                              'invisible 'gptel-skill)))))))
#+end_src

* Interactive Commands (Phase 5)

** Insert Mention

#+begin_src emacs-lisp
(defun jf/gptel-skills-insert-mention (skill-name)
  "Insert @mention for SKILL-NAME at point.
Prompts for skill using completing-read."
  (interactive
   (list (completing-read "Insert skill: "
                         (hash-table-keys jf/gptel-skills--registry)
                         nil t)))
  (insert jf/gptel-skills-mention-prefix skill-name)
  ;; Trigger overlay update
  (jf/gptel-skills--update-overlays))
#+end_src

** List Active Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills-list-active ()
  "Display currently active skills in minibuffer or buffer."
  (interactive)
  (if (null jf/gptel-skills--active)
      (message "No active skills in current buffer")
    (let ((skill-info
           (mapcar (lambda (name)
                    (let* ((metadata (gethash name jf/gptel-skills--registry))
                           (mode (plist-get metadata :injection-mode)))
                      (format "%s (%s)" name mode)))
                  jf/gptel-skills--active)))
      (message "Active skills: %s" (string-join skill-info ", ")))))
#+end_src

** Clear Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills-clear-mentions ()
  "Remove all @mentions from buffer."
  (interactive)
  (when (yes-or-no-p "Remove all @skill mentions from buffer? ")
    (save-excursion
      (goto-char (point-min))
      (let ((prefix (regexp-quote jf/gptel-skills-mention-prefix)))
        (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
          (let ((skill-name (match-string 1)))
            (when (gethash skill-name jf/gptel-skills--registry)
              (delete-region (match-beginning 0) (match-end 0))
              ;; Clean up extra spaces
              (when (looking-at " +")
                (delete-region (point) (match-end 0))))))))
    (jf/gptel-skills--update-overlays)
    (message "Cleared all skill mentions")))
#+end_src

** Reload Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills-reload ()
  "Reload all skills from directory.
Clears cache, re-scans directory, and updates registry."
  (interactive)

  ;; Clear registry
  (clrhash jf/gptel-skills--registry)

  ;; Discover skills
  (let ((skill-files (jf/gptel-skills--discover)))
    (if (null skill-files)
        (message "No skills found in %s" jf/gptel-skills-directory)

      ;; Parse and register each skill
      (dolist (skill-file skill-files)
        (let ((metadata (jf/gptel-skills--parse-metadata skill-file)))
          (when metadata
            (let ((name (plist-get metadata :name)))
              (puthash name metadata jf/gptel-skills--registry)))))

      (message "Loaded %d skill(s) from %s"
               (hash-table-count jf/gptel-skills--registry)
               jf/gptel-skills-directory)

      ;; Update overlays in all gptel buffers
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (derived-mode-p 'gptel-mode)
            (jf/gptel-skills--update-overlays)))))))
#+end_src

** Describe Skill

#+begin_src emacs-lisp
(defun jf/gptel-skills-describe (skill-name)
  "Show description and metadata for SKILL-NAME."
  (interactive
   (list (completing-read "Describe skill: "
                         (hash-table-keys jf/gptel-skills--registry)
                         nil t)))
  (let ((metadata (gethash skill-name jf/gptel-skills--registry)))
    (if (not metadata)
        (message "Skill not found: %s" skill-name)
      (with-output-to-temp-buffer (format "*Skill: %s*" skill-name)
        (princ (format "Skill: %s\n\n" skill-name))
        (princ (format "Description: %s\n" (plist-get metadata :description)))
        (princ (format "Injection mode: %s\n" (plist-get metadata :injection-mode)))
        (princ (format "Path: %s\n" (plist-get metadata :path)))
        (princ (format "Loaded: %s\n" (if (plist-get metadata :loaded) "yes" "no")))
        (when (plist-get metadata :loaded)
          (princ (format "\nContent length: %d characters\n"
                        (length (plist-get metadata :content)))))))))
#+end_src

* Initialization

** Setup

#+begin_src emacs-lisp
(defun jf/gptel-skills-setup ()
  "Initialize the skills system.
Called automatically when this module is loaded."
  (when (file-directory-p (expand-file-name jf/gptel-skills-directory))
    (jf/gptel-skills-reload)))
#+end_src

** Hook Installation

#+begin_src emacs-lisp
;; Initialize skills and setup hooks when gptel is loaded
(with-eval-after-load 'gptel
  ;; Load skills
  (jf/gptel-skills-setup)

  ;; Add transform function to gptel
  (add-hook 'gptel-prompt-transform-functions
            #'jf/gptel-skills--transform-inject)

  ;; Add buffer-local hooks for gptel buffers
  (add-hook 'gptel-mode-hook
            (lambda ()
              ;; Update overlays on buffer changes
              (add-hook 'after-change-functions
                        #'jf/gptel-skills--update-overlays nil t)
              ;; Enable completion
              (add-hook 'completion-at-point-functions
                        #'jf/gptel-skills--completion-at-point nil t))))

;; If gptel is already loaded, initialize now
(when (featurep 'gptel)
  (jf/gptel-skills-setup))
#+end_src

* Keybindings

#+begin_src emacs-lisp
;; Define keybindings in gptel-mode
(with-eval-after-load 'gptel
  (when (boundp 'gptel-mode-map)
    (define-key gptel-mode-map (kbd "C-c @ i") 'jf/gptel-skills-insert-mention)
    (define-key gptel-mode-map (kbd "C-c @ l") 'jf/gptel-skills-list-active)
    (define-key gptel-mode-map (kbd "C-c @ c") 'jf/gptel-skills-clear-mentions)
    (define-key gptel-mode-map (kbd "C-c @ d") 'jf/gptel-skills-describe)
    (define-key gptel-mode-map (kbd "C-c @ r") 'jf/gptel-skills-reload)))
#+end_src

* Provide

#+begin_src emacs-lisp
(provide 'gptel-skills)
;;; gptel-skills.el ends here
#+end_src
