#+title: GPTel Skills System (@Mention-Based)
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle gptel-skills.el
#+auto_tangle: y

* Introduction

This module implements a dynamic skills system for gptel that allows explicit skill
activation via =@skill-name= mentions during conversations. Skills are Claude Code skills
from =~/.claude/skills/= that provide context, guidelines, and reference material.

** Architecture Overview

The skills system operates in four phases, each serving a specific purpose in the
@mention-to-injection pipeline:

1. **Discovery** (initialization): Scan skills directory (=~/.claude/skills/= for markdown,
   =~/.org-roam/skills/= for org-roam), parse metadata (name, description, injection-mode)
   with lazy loading. Both skill types are unified in a single registry.

2. **Mention Detection** (typing): As you type in gptel buffers, the system detects
   =@skill-name= patterns, validates against the registry, and creates visual overlays
   with help-echo descriptions. Updates buffer-local active skills list.

3. **Dynamic Injection** (sending): When you press =C-c RET= to send, hooks into
   =gptel-prompt-transform-functions= to:
   - Load skill content (if not cached)
   - Determine injection mode (system/context/user via heuristics or explicit setting)
   - Inject content into appropriate location
   - Strip @mentions from visible prompt

4. **Progressive Disclosure** (optional): Load additional resources referenced within
   skills (currently basic support via =jf/gptel-skills--load-resource=)

** Key Features

- **Explicit activation**: Type =@skill-name= in gptel buffer
- **Visual feedback**: Overlays show active skills (like @mentions)
- **Smart injection**: Content goes to system message, context, or user message
- **Lazy loading**: Skills load on first mention, then cached
- **Completion support**: TAB completion for skill names

** Usage Example

#+begin_example
User types in gptel buffer:
"Help me write elisp @writing-elisp"
                       ^^^^^^^^^^^^^^ <- overlay appears (green underline + description on hover)

User sends (C-c RET):
→ Transform hook detects @writing-elisp
→ Loads skill content (lazy, cached after first load)
→ Analyzes content → determines injection-mode='system (behavioral guidance)
→ Appends to gptel--system-message:
  "\n\n## Skill: writing-elisp\n\n[skill content with elisp best practices]"
→ Strips @mention from prompt (makes invisible)
→ Request sent to LLM with enhanced system message

Result: LLM receives behavioral guidance about elisp without @mention clutter
#+end_example

** System Architecture Diagram

#+begin_example
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                         GPTEL SKILLS SYSTEM                                            │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘

INITIALIZATION (Phase 1: Discovery)
┌─────────────────────────────────────┐     ┌─────────────────────────────────────┐
│ ~/.claude/skills/*/SKILL.md         │     │ ~/.org-roam/skills/*.org            │
│ (Markdown skills)                   │     │ (Org-roam skills)                   │
└────────────┬────────────────────────┘     └────────────┬────────────────────────┘
             │                                            │
             │ jf/gptel-skills--discover()               │ jf/gptel-skills-roam--discover-files()
             │ jf/gptel-skills--parse-metadata()         │ jf/gptel-skills-roam--parse-file-metadata()
             │                                            │
             └────────────────┬───────────────────────────┘
                              ↓
                 ┌────────────────────────────────────────────┐
                 │  jf/gptel-skills--registry (hash table)    │
                 │  Keys: skill-name (string)                 │
                 │  Values: metadata plist                    │
                 │    :name :description :injection-mode      │
                 │    :path/:file :source :loaded :content    │
                 └────────────────────────────────────────────┘

USER INTERACTION (Phase 2: Mention Detection & Visual Feedback)
┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  GPTEL BUFFER (with gptel-mode enabled)                                                             │
│  ┌───────────────────────────────────────────────────────────────────────────────────────────────┐ │
│  │ User prompt: "Help me write elisp @writing-elisp"                                             │ │
│  │                                     ^^^^^^^^^^^^^^^^                                           │ │
│  │                                     │ Overlay with face + help-echo                           │ │
│  └───────────────────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                            ↑
                                            │
                        ┌───────────────────┴────────────────────┐
                        │ after-change-functions hook            │
                        │ jf/gptel-skills--update-overlays()     │
                        │   ├─ detect mentions                   │
                        │   ├─ create overlays                   │
                        │   └─ update jf/gptel-skills--active    │
                        └────────────────────────────────────────┘

SENDING REQUEST (Phase 3: Dynamic Injection)
User presses C-c RET (gptel-send)
             ↓
┌────────────────────────────────────────────────────────────────────────────────────────┐
│ gptel-prompt-transform-functions hook                                                  │
│ jf/gptel-skills--transform-inject(fsm)                                                 │
│   ├─ Detect mentions                                                                   │
│   ├─ Load content (lazy, with caching)                                                 │
│   ├─ Determine injection mode (auto detection or explicit)                             │
│   │   ├─ system:  Content prepended to gptel--system-message                           │
│   │   ├─ context: Content placed in temp buffer, added to gptel-context list           │
│   │   └─ user:    Content inserted at top of prompt buffer                             │
│   └─ Strip @mentions (make invisible)                                                  │
└────────────────────────────────────────────────────────────────────────────────────────┘
             ↓
        Request sent to LLM with skill content injected
#+end_example

* Configuration

Setup lexical binding and dependencies.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
(require 'gptel nil t)
(require 'gptel-skills-roam nil t)
#+end_src

** Customization Variables

#+begin_src emacs-lisp
(defgroup gptel-skills nil
  "Skills system for gptel with @mention activation."
  :group 'gptel
  :prefix "jf/gptel-skills-")

(defcustom jf/gptel-skills-directory "~/.claude/skills"
  "Directory containing Claude Code skills.
Skills should be organized as SKILL-NAME/SKILL.md."
  :type 'directory
  :group 'gptel-skills)

(defcustom jf/gptel-skills-mention-prefix "@"
  "Prefix character for skill mentions in buffer."
  :type 'string
  :group 'gptel-skills)

(defcustom jf/gptel-skills-strip-mentions t
  "Whether to strip @mentions from prompt before sending.
If nil, mentions are kept in the prompt (visible to LLM)."
  :type 'boolean
  :group 'gptel-skills)

(defcustom jf/gptel-skills-auto-expand nil
  "Automatically load referenced resources without prompting."
  :type 'boolean
  :group 'gptel-skills)

(defcustom jf/gptel-skills-verbose nil
  "When non-nil, print verbose messages during skill operations."
  :type 'boolean
  :group 'gptel-skills)
#+end_src

** Face Definitions

#+begin_src emacs-lisp
(defface jf/gptel-skills-mention-face
  '((t :inherit font-lock-keyword-face :underline t))
  "Face for @skill mentions in gptel buffers.")
#+end_src

* Data Structures

#+begin_src emacs-lisp
(defvar jf/gptel-skills--registry (make-hash-table :test 'equal)
  "Hash table mapping skill names to metadata plists.

This registry contains both markdown (.md) and org-roam skills.

Each entry is a plist with keys:
  :name          - Skill name (string)
  :description   - Description for completion/help (string)
  :path          - Full path to SKILL.md file (string) [markdown only]
  :dir           - Skill directory path (string) [markdown only]
  :file          - Full path to .org skill file (string) [org-roam only]
  :source        - Source type: 'markdown or 'org-roam (symbol)
  :injection-mode - Where to inject: system|context|user|auto (symbol)
  :loaded        - Whether content has been loaded (boolean)
  :content       - Cached skill content (string or nil)")

(defvar-local jf/gptel-skills--active nil
  "List of skill names active in current buffer via @mentions.")

(defvar-local jf/gptel-skills--overlays nil
  "List of skill mention overlays in current buffer.")
#+end_src

** Component Relationships Diagram

#+begin_example
┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                   COMPONENT RELATIONSHIP DIAGRAM                                     │
└─────────────────────────────────────────────────────────────────────────────────────────────────────┘

CORE DATA STRUCTURES
┌───────────────────────────────────────────────┐
│ jf/gptel-skills--registry (hash table)        │
│   Populated by:                               │
│   • jf/gptel-skills--discover()               │
│   • jf/gptel-skills--parse-metadata()         │
│   • jf/gptel-skills-roam--discover-files()    │
│   • jf/gptel-skills-roam--parse-file-metadata()│
│                                                │
│   Queried by:                                  │
│   • jf/gptel-skills--detect-mentions()        │
│   • jf/gptel-skills--completion-at-point()    │
│   • jf/gptel-skills--transform-inject()       │
│                                                │
│   Modified by:                                 │
│   • jf/gptel-skills--transform-inject()       │
│     (loads content, updates :loaded/:content) │
└───────────────────────────────────────────────┘
                    ↓
┌───────────────────────────────────────────────┐
│ jf/gptel-skills--active (buffer-local list)   │
│   Updated by:                                  │
│   • jf/gptel-skills--update-overlays()        │
│                                                │
│   Used by:                                     │
│   • jf/gptel-skills-list-active()             │
└───────────────────────────────────────────────┘
                    ↓
┌───────────────────────────────────────────────┐
│ jf/gptel-skills--overlays (buffer-local list) │
│   Updated by:                                  │
│   • jf/gptel-skills--add-overlay()            │
│   • jf/gptel-skills--update-overlays()        │
│                                                │
│   Cleared by:                                  │
│   • jf/gptel-skills-clear-mentions()          │
│   • jf/gptel-skills-reload()                  │
└───────────────────────────────────────────────┘

HOOK INTEGRATION
┌────────────────────────────────────────────────────────────────────────────────────────┐
│ gptel-mode enabled                                                                     │
│   ├─ gptel-mode-hook                                                                   │
│   │   ├─ after-change-functions ← jf/gptel-skills--update-overlays()                  │
│   │   └─ completion-at-point-functions ← jf/gptel-skills--completion-at-point()       │
│   │                                                                                     │
│   └─ gptel-prompt-transform-functions ← jf/gptel-skills--transform-inject(fsm)        │
└────────────────────────────────────────────────────────────────────────────────────────┘
#+end_example

* Discovery and Parsing (Phase 1)

** Discover Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills--discover ()
  "Scan skills directory and return list of SKILL.md file paths.
Returns list of absolute paths to SKILL.md files."
  (let ((skills-dir (expand-file-name jf/gptel-skills-directory)))
    (when (file-directory-p skills-dir)
      (let ((skill-files '()))
        (dolist (entry (directory-files skills-dir t "^[^.]" t))
          (when (file-directory-p entry)
            (let ((skill-file (expand-file-name "SKILL.md" entry)))
              (when (file-exists-p skill-file)
                (push skill-file skill-files)))))
        (nreverse skill-files)))))
#+end_src

** Parse Metadata

#+begin_src emacs-lisp
(defun jf/gptel-skills--parse-metadata (skill-path)
  "Parse YAML frontmatter from SKILL.md at SKILL-PATH.
Returns plist with :name, :description, :injection-mode, :path, :dir.
Returns nil if parsing fails."
  (condition-case err
      (with-temp-buffer
        (insert-file-contents skill-path)
        (goto-char (point-min))

        ;; Check for YAML frontmatter delimiter
        (if (not (looking-at "^---[ \t]*$"))
            (progn
              (when jf/gptel-skills-verbose
                (message "Warning: No YAML frontmatter in %s" skill-path))
              nil)

          ;; Parse YAML frontmatter
          (forward-line 1)
          (let ((yaml-start (point))
                (yaml-end nil)
                (metadata '()))

            ;; Find end of frontmatter
            (when (re-search-forward "^---[ \t]*$" nil t)
              (setq yaml-end (match-beginning 0))

              ;; Parse name
              (goto-char yaml-start)
              (when (re-search-forward "^name:[ \t]+\\(.+\\)$" yaml-end t)
                (setq metadata (plist-put metadata :name (string-trim (match-string 1)))))

              ;; Parse description
              (goto-char yaml-start)
              (when (re-search-forward "^description:[ \t]+\\(.+\\)$" yaml-end t)
                (setq metadata (plist-put metadata :description (string-trim (match-string 1)))))

              ;; Parse injection-mode
              (goto-char yaml-start)
              (when (re-search-forward "^injection-mode:[ \t]+\\(system\\|context\\|user\\|auto\\)$" yaml-end t)
                (setq metadata (plist-put metadata :injection-mode (intern (match-string 1)))))

              ;; Add path, directory, and source
              (setq metadata (plist-put metadata :path skill-path))
              (setq metadata (plist-put metadata :dir (file-name-directory skill-path)))
              (setq metadata (plist-put metadata :source 'markdown))

              ;; Set defaults
              (unless (plist-get metadata :name)
                (setq metadata (plist-put metadata :name
                                          (file-name-base (directory-file-name
                                                          (file-name-directory skill-path))))))
              (unless (plist-get metadata :description)
                (setq metadata (plist-put metadata :description
                                          (plist-get metadata :name))))
              (unless (plist-get metadata :injection-mode)
                (setq metadata (plist-put metadata :injection-mode 'auto)))

              ;; Initialize loading state
              (setq metadata (plist-put metadata :loaded nil))
              (setq metadata (plist-put metadata :content nil))

              metadata))))
    (error
     (message "Error parsing skill metadata from %s: %s" skill-path (error-message-string err))
     nil)))
#+end_src

** Parse Content

#+begin_src emacs-lisp
(defun jf/gptel-skills--parse-content (skill-path)
  "Read full SKILL.md content from SKILL-PATH, excluding YAML frontmatter.
Returns content as string, or nil on error."
  (condition-case err
      (with-temp-buffer
        (insert-file-contents skill-path)
        (goto-char (point-min))

        ;; Skip YAML frontmatter if present
        (when (looking-at "^---[ \t]*$")
          (forward-line 1)
          (when (re-search-forward "^---[ \t]*$" nil t)
            (forward-line 1)))

        ;; Return rest of buffer
        (buffer-substring-no-properties (point) (point-max)))
    (error
     (message "Error reading skill content from %s: %s" skill-path (error-message-string err))
     nil)))
#+end_src

** Load Resource

#+begin_src emacs-lisp
(defun jf/gptel-skills--load-resource (skill-dir resource-file)
  "Load additional resource file from SKILL-DIR.
RESOURCE-FILE is relative filename (e.g., 'REFERENCE.md').
Returns content as string, or nil if file doesn't exist."
  (let ((resource-path (expand-file-name resource-file skill-dir)))
    (when (file-exists-p resource-path)
      (condition-case err
          (with-temp-buffer
            (insert-file-contents resource-path)
            (buffer-string))
        (error
         (message "Error loading resource %s: %s" resource-path (error-message-string err))
         nil)))))
#+end_src

* Mention Detection and Visual Feedback (Phase 2)

** Detect Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills--detect-mentions (&optional buffer)
  "Scan BUFFER for @skill-name patterns.
Returns list of (skill-name . position) tuples for valid skills.
If BUFFER is nil, uses current buffer."
  (with-current-buffer (or buffer (current-buffer))
    (let ((mentions '())
          (prefix (regexp-quote jf/gptel-skills-mention-prefix))
          (skill-names (hash-table-keys jf/gptel-skills--registry)))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
          (let ((skill-name (match-string 1))
                (pos (match-beginning 0)))
            ;; Only include if skill exists in registry
            (when (member skill-name skill-names)
              (push (cons skill-name pos) mentions)))))
      (nreverse mentions))))
#+end_src

** Add Overlay

#+begin_src emacs-lisp
(defun jf/gptel-skills--add-overlay (beg end skill-name)
  "Create overlay marking @mention from BEG to END for SKILL-NAME."
  (let* ((metadata (gethash skill-name jf/gptel-skills--registry))
         (description (plist-get metadata :description))
         (ov (make-overlay beg end nil t nil)))
    (overlay-put ov 'face 'jf/gptel-skills-mention-face)
    (overlay-put ov 'gptel-skill skill-name)
    (overlay-put ov 'help-echo description)
    (overlay-put ov 'evaporate t)
    (overlay-put ov 'priority 100)
    (push ov jf/gptel-skills--overlays)
    ov))
#+end_src

** Update Overlays

#+begin_src emacs-lisp
(defun jf/gptel-skills--update-overlays (&optional _beg _end _len)
  "Update overlays and active skills list based on current @mentions.
Designed to be called from after-change-functions."
  (when (and (bound-and-true-p gptel-mode)  ; gptel-mode is a minor mode
             (hash-table-p jf/gptel-skills--registry)
             (> (hash-table-count jf/gptel-skills--registry) 0))
    ;; Remove all existing overlays
    (mapc #'delete-overlay jf/gptel-skills--overlays)
    (setq jf/gptel-skills--overlays nil)

    ;; Detect current mentions
    (let* ((mentions (jf/gptel-skills--detect-mentions))
           (skill-names (mapcar #'car mentions)))

      ;; Create overlays for each mention
      (dolist (mention mentions)
        (let* ((skill-name (car mention))
               (pos (cdr mention))
               (end-pos (+ pos (length jf/gptel-skills-mention-prefix)
                          (length skill-name))))
          (jf/gptel-skills--add-overlay pos end-pos skill-name)))

      ;; Update active skills list
      (setq jf/gptel-skills--active (delete-dups skill-names)))))
#+end_src

** Completion at Point

#+begin_src emacs-lisp
(defun jf/gptel-skills--completion-at-point ()
  "Provide completion for @skill mentions.
Integrates with completion-at-point-functions."
  (when (and (bound-and-true-p gptel-mode)  ; gptel-mode is a minor mode
             (> (hash-table-count jf/gptel-skills--registry) 0))
    (let* ((prefix (regexp-quote jf/gptel-skills-mention-prefix))
           (bounds (bounds-of-thing-at-point 'symbol))
           (start (and bounds (car bounds)))
           (end (and bounds (cdr bounds))))
      ;; Check if we're after @ prefix
      (when (and start
                 (> start (point-min))
                 (string= (buffer-substring-no-properties (1- start) start)
                          jf/gptel-skills-mention-prefix))
        (list (1- start)  ; include the @
              end
              (mapcar (lambda (name)
                       (concat jf/gptel-skills-mention-prefix name))
                     (hash-table-keys jf/gptel-skills--registry))
              :exclusive 'no
              :annotation-function
              (lambda (candidate)
                (let* ((skill-name (substring candidate (length jf/gptel-skills-mention-prefix)))
                       (metadata (gethash skill-name jf/gptel-skills--registry))
                       (mode (plist-get metadata :injection-mode))
                       (source (plist-get metadata :source)))
                  (format " (%s %s)"
                          (or mode 'auto)
                          (cond
                           ((eq source 'org-roam) "org-roam")
                           ((eq source 'markdown) "md")
                           (t ""))))))))))
#+end_src

** Injection Strategy Decision Tree

#+begin_example
┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                             INJECTION MODE DETERMINATION FLOWCHART                                   │
└─────────────────────────────────────────────────────────────────────────────────────────────────────┘

jf/gptel-skills--transform-inject()
            ↓
    Get skill metadata from registry
            ↓
    ┌───────────────────────┐
    │ Injection mode set?   │
    └───────┬───────────────┘
            │
   ┌────────┴────────┐
   │                 │
  YES               NO (mode = 'auto)
   │                 │
   │                 ↓
   │     jf/gptel-skills--determine-injection-mode(metadata, content)
   │                 │
   │        ┌────────┴───────────────────────────────────────┐
   │        │ Content starts with:                           │
   │        │ "You are", "When", "Always", "Never"?          │
   │        └────┬───────────────────────────────────────┬───┘
   │            YES                                      NO
   │             │                                        │
   │             ↓                                        ↓
   │          'system                        ┌──────────────────────────┐
   │                                         │ Content has code blocks, │
   │                                         │ tables, or >1000 chars?  │
   │                                         └────┬─────────────────┬───┘
   │                                             YES               NO
   │                                              │                 │
   │                                              ↓                 ↓
   │                                          'context      ┌──────────────┐
   │                                                        │ Numbered     │
   │                                                        │ list "1."?   │
   │                                                        └───┬──────┬───┘
   │                                                           YES    NO
   │                                                            │      │
   │                                                            ↓      ↓
   │                                                          'user  'system
   │                                                                   │
   └───────────────────────────────────────────────────────────────────┘
                                    ↓
                    jf/gptel-skills--inject-content(content, mode, skill-name)
                                    │
          ┌─────────────────────────┼─────────────────────────┐
          │                         │                          │
      mode='system             mode='context              mode='user
          │                         │                          │
          ↓                         ↓                          ↓
   Append to               Create temp buffer          Insert at buffer start
   gptel--system-message   Add to gptel-context        with "## Reference:" header
   with "## Skill:" header
#+end_example

* Dynamic Injection (Phase 3)

** Understanding the Transform Hook and FSM

The gptel-skills system integrates with gptel through the =gptel-prompt-transform-functions=
hook, which provides a powerful extension point for modifying requests before they're sent
to the LLM.

*** What is the FSM?

FSM is a finite state machine object (gptel-fsm) created by =gptel-request.el= that tracks
the complete lifecycle of an LLM request. It's passed to all transform functions to provide:

- Access to request metadata via =(gptel-fsm-info fsm)=
- Context about where the request originated
- Information about the target backend and model
- The temporary buffer containing the prompt text

*** Hook Execution Context

When =gptel-prompt-transform-functions= runs:

1. A temporary buffer is created containing the prompt text
2. The hook runs IN THIS TEMP BUFFER with point at the end of the prompt
3. Buffer-local variables from the originating buffer are accessible
4. Transform functions can modify the temp buffer content
5. Transform functions can modify buffer-local variables like:
   - =gptel--system-message= (prepend to system instructions)
   - =gptel-context= (add additional context buffers/files)

*** FSM Info Structure

The FSM contains a plist accessible via =(gptel-fsm-info fsm)=:

| Key | Type | Description |
|-----|------|-------------|
| =:buffer= | buffer | Original gptel buffer where request was initiated |
| =:backend= | gptel-backend | Active LLM backend (Anthropic, OpenAI, etc) |
| =:data= | buffer | Temporary buffer containing prompt text to send |
| =:position= | integer | Position in original buffer |
| =:stream= | boolean | Whether streaming is enabled |
| =:system= | string | System message for this request |

*** Transform Function Contract

Transform functions in =gptel-prompt-transform-functions= can be:

*Synchronous* (1 argument):
#+begin_src emacs-lisp
(defun my-transform (fsm)
  "Transform function that runs and completes immediately."
  ;; Modify temp buffer or variables
  ;; No return value needed
  )
#+end_src

*Asynchronous* (2 arguments):
#+begin_src emacs-lisp
(defun my-async-transform (callback fsm)
  "Transform function that may need to wait for external operations."
  ;; Do async work
  ;; Call (funcall callback) when done
  )
#+end_src

*** What jf/gptel-skills--transform-inject Does

1. Detects @mentions in the temp buffer
2. Loads skill content (lazy loading with caching)
3. Determines injection mode (system/context/user)
4. Modifies the appropriate variable:
   - System mode: Appends to =gptel--system-message=
   - Context mode: Creates temp buffer, adds to =gptel-context=
   - User mode: Inserts content at top of temp buffer
5. Strips @mentions from the temp buffer (makes them invisible)

The transform function does NOT return anything - it modifies state in place.

** Transform Inject

#+begin_src emacs-lisp
(defun jf/gptel-skills--transform-inject (fsm)
  "Main prompt transform function for injecting skills.
Detects @mentions, loads content, determines injection mode, and injects.
Added to gptel-prompt-transform-functions. FSM is the state machine."
  (when (> (hash-table-count jf/gptel-skills--registry) 0)
    ;; Always detect mentions directly - don't rely on jf/gptel-skills--active
    ;; since that depends on overlays which might not be set up yet
    (let ((mentions (jf/gptel-skills--detect-mentions)))
      (when mentions
        (dolist (mention mentions)
          (let* ((skill-name (car mention))
                 (metadata (gethash skill-name jf/gptel-skills--registry)))
            (when metadata
              ;; Load content if not already loaded
              (unless (plist-get metadata :loaded)
                (let* ((source (plist-get metadata :source))
                       (content (cond
                                 ;; Markdown skills - use existing parser
                                 ((eq source 'markdown)
                                  (jf/gptel-skills--parse-content (plist-get metadata :path)))
                                 ;; Org-roam skills - read file directly
                                 ((eq source 'org-roam)
                                  (let ((file (plist-get metadata :file)))
                                    (when (and file (file-exists-p file))
                                      (with-temp-buffer
                                        (insert-file-contents file)
                                        (buffer-string)))))
                                 (t nil))))
                  (when content
                    (plist-put metadata :loaded t)
                    (plist-put metadata :content content)
                    (puthash skill-name metadata jf/gptel-skills--registry))))

              ;; Get content and determine injection mode
              (let ((content (plist-get metadata :content)))
                (when content
                  (let* ((mode-specified (plist-get metadata :injection-mode))
                         (mode (if (eq mode-specified 'auto)
                                  (jf/gptel-skills--determine-injection-mode metadata content)
                                mode-specified)))

                    (when mode
                      (when jf/gptel-skills-verbose
                        (message "Injecting skill: %s (mode: %s)" skill-name mode))

                      ;; Inject based on mode
                      (jf/gptel-skills--inject-content content mode skill-name))))))))

        ;; Strip @mentions if configured
        (when jf/gptel-skills-strip-mentions
          (jf/gptel-skills--strip-mentions))))))
#+end_src

** Determine Injection Mode

#+begin_src emacs-lisp
(defun jf/gptel-skills--determine-injection-mode (metadata content)
  "Analyze CONTENT and determine best injection mode.
Returns symbol: system, context, or user."
  ;; Simple heuristic analysis
  (cond
   ;; Behavioral guidelines → system
   ((string-match-p "^\\(You are\\|When \\|Always \\|Never \\)" content)
    'system)

   ;; Has code blocks, tables, references → context
   ((or (string-match-p "```" content)
        (string-match-p "^|.*|$" content)
        (> (length content) 1000))
    'context)

   ;; Has numbered steps, immediate instructions → user
   ((string-match-p "^[0-9]+\\." content)
    'user)

   ;; Default: system (behavioral guidance)
   (t 'system)))
#+end_src

*** Injection Mode Determination: Detailed Explanation

When a skill's =injection-mode= is set to =auto=, the system analyzes the content
to determine the best placement. This section explains the heuristics and reasoning.

**** The Three Injection Modes

| Mode | Target | Use Case |
|------|--------|----------|
| =system= | =gptel--system-message= | Behavioral guidelines, persona definition, general rules |
| =context= | =gptel-context= buffers | Reference material, code examples, documentation |
| =user= | Prompt buffer (top) | Immediate instructions, step-by-step procedures |

**** Detection Heuristics (in order of precedence)

**1. Behavioral Directives → system**

Content starting with imperative behavioral language goes to system message:

Examples:
#+begin_example
"You are an expert in Emacs Lisp..."           → system
"When writing elisp, always use..."            → system
"Always prefer higher-order functions..."      → system
"Never use eval unless absolutely necessary"   → system
#+end_example

*Rationale*: These define HOW the LLM should behave across the conversation.
They're meta-instructions about approach, not specific to the current query.

**2. Large Reference Material → context**

Content with substantial reference material goes to context buffers:

Examples:
#+begin_example
"```elisp\n(defun foo ()...```"               → context (code blocks)
"| Function | Description |\n|---|---|"       → context (tables)
"[5000 character API reference]"              → context (>1000 chars)
#+end_example

*Rationale*: Large reference material works better as separate context that
the LLM can reference. Keeps system message focused and avoids cluttering
the user prompt.

**3. Procedural Steps → user**

Content with numbered procedures goes to top of user prompt:

Examples:
#+begin_example
"1. First, analyze the problem\n2. Then..." → user
"1. Create the function\n2. Add tests"      → user
#+end_example

*Rationale*: Step-by-step procedures are immediate instructions for THIS query.
They should appear as part of the user's request, not as system behavior.

**4. Default → system**

Brief guidance text without specific markers:

Examples:
#+begin_example
"Use proper error handling"                  → system (default)
"Prefer immutable data structures"           → system (default)
#+end_example

*Rationale*: General guidance without strong signals defaults to behavioral
instruction (system message) as the safest placement.

**** Edge Cases and Override

Users can override auto-detection by setting =injection-mode= explicitly:

#+begin_example
---
name: my-skill
injection-mode: context  # Force context mode regardless of content
---
#+end_example

This is useful when:
- Auto-detection chooses wrong mode for your use case
- You want consistent behavior regardless of content changes
- You have specific integration requirements

** Inject Content

#+begin_src emacs-lisp
(defun jf/gptel-skills--inject-content (content mode skill-name)
  "Inject CONTENT based on MODE for SKILL-NAME.
MODE is symbol: system, context, or user."
  (pcase mode
    ('system
     ;; Append to system message
     (setq-local gptel--system-message
                (if gptel--system-message
                    (concat gptel--system-message
                            (format "\n\n## Skill: %s\n\n" skill-name)
                            content)
                  (concat (format "## Skill: %s\n\n" skill-name)
                          content))))

    ('context
     ;; Add to gptel-context as a buffer-like source
     (let ((temp-buf (generate-new-buffer (format " *gptel-skill-%s*" skill-name))))
       (with-current-buffer temp-buf
         (insert (format "# Skill: %s\n\n" skill-name))
         (insert content))
       ;; Add to context list
       (setq-local gptel-context
                  (append gptel-context (list temp-buf)))))

    ('user
     ;; Insert directly in prompt buffer at beginning
     (save-excursion
       (goto-char (point-min))
       (insert (format "## Reference: %s\n\n" skill-name))
       (insert content)
       (insert "\n\n---\n\n")))))
#+end_src

*** Injection Examples: Before and After

This section shows concrete examples of how skill content is injected for each mode.

**** System Mode Injection

**Scenario**: Skill contains behavioral guidelines

Before injection:
#+begin_example
gptel--system-message = "You are a helpful assistant"
#+end_example

After =jf/gptel-skills--inject-content= with mode='system:
#+begin_example
gptel--system-message = "You are a helpful assistant

## Skill: writing-elisp

Always use lexical binding. Prefer higher-order functions.
Use cl-lib instead of deprecated cl package. Include docstrings
for all public functions."
#+end_example

**Result**: Behavioral guidance is appended to system message, influencing all
responses in the conversation.

**** Context Mode Injection

**Scenario**: Skill contains large reference material or code examples

Before injection:
#+begin_example
gptel-context = (buffer1 buffer2)
#+end_example

After =jf/gptel-skills--inject-content= with mode='context:
#+begin_example
gptel-context = (buffer1 buffer2 *gptel-skill-writing-elisp*)

Contents of *gptel-skill-writing-elisp* buffer:
# Skill: writing-elisp

```elisp
(defun example-function ()
  (let* ((x 1) (y 2))
    (+ x y)))
```

Common patterns:
| Pattern | Example | Use case |
|---------|---------|----------|
| ...
#+end_example

**Result**: Reference material is sent as separate context buffer, allowing LLM
to reference it without cluttering system message or user prompt.

**** User Mode Injection

**Scenario**: Skill contains immediate procedural instructions

Buffer content before injection:
#+begin_example
"Help me write elisp @writing-elisp"
#+end_example

After =jf/gptel-skills--inject-content= with mode='user:
#+begin_example
"## Reference: writing-elisp

1. Start with lexical binding declaration
2. Add docstrings to public functions
3. Use cl-lib for advanced features
4. Test incrementally

---

Help me write elisp @writing-elisp"
#+end_example

**Result**: Procedural steps appear at top of user prompt as immediate
instructions for this specific query.

** Strip Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills--strip-mentions ()
  "Remove or hide @mentions from prompt buffer.
Uses invisible text property to hide mentions."
  (save-excursion
    (goto-char (point-min))
    (let ((prefix (regexp-quote jf/gptel-skills-mention-prefix)))
      (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
        (let ((skill-name (match-string 1)))
          ;; Only strip if skill is in registry
          (when (gethash skill-name jf/gptel-skills--registry)
            ;; Make invisible
            (put-text-property (match-beginning 0) (match-end 0)
                              'invisible 'gptel-skill)))))))
#+end_src

* Interactive Commands (Phase 5)

** Insert Mention

#+begin_src emacs-lisp
(defun jf/gptel-skills-insert-mention (skill-name)
  "Insert @mention for SKILL-NAME at point.
Prompts for skill using completing-read."
  (interactive
   (list (completing-read "Insert skill: "
                         (hash-table-keys jf/gptel-skills--registry)
                         nil t)))
  (insert jf/gptel-skills-mention-prefix skill-name)
  ;; Trigger overlay update
  (jf/gptel-skills--update-overlays))
#+end_src

** List Active Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills-list-active ()
  "Display currently active skills in minibuffer or buffer."
  (interactive)
  (if (null jf/gptel-skills--active)
      (message "No active skills in current buffer")
    (let ((skill-info
           (mapcar (lambda (name)
                    (let* ((metadata (gethash name jf/gptel-skills--registry))
                           (mode (plist-get metadata :injection-mode)))
                      (format "%s (%s)" name mode)))
                  jf/gptel-skills--active)))
      (message "Active skills: %s" (string-join skill-info ", ")))))
#+end_src

** Clear Mentions

#+begin_src emacs-lisp
(defun jf/gptel-skills-clear-mentions ()
  "Remove all @mentions from buffer."
  (interactive)
  (when (yes-or-no-p "Remove all @skill mentions from buffer? ")
    (save-excursion
      (goto-char (point-min))
      (let ((prefix (regexp-quote jf/gptel-skills-mention-prefix)))
        (while (re-search-forward (concat prefix "\\([a-zA-Z0-9_-]+\\)") nil t)
          (let ((skill-name (match-string 1)))
            (when (gethash skill-name jf/gptel-skills--registry)
              (delete-region (match-beginning 0) (match-end 0))
              ;; Clean up extra spaces
              (when (looking-at " +")
                (delete-region (point) (match-end 0))))))))
    (jf/gptel-skills--update-overlays)
    (message "Cleared all skill mentions")))
#+end_src

** Reload Skills

#+begin_src emacs-lisp
(defun jf/gptel-skills-reload ()
  "Reload all skills from directory and org-roam.
Clears cache, re-scans directory, and updates registry with both
markdown and org-roam skills."
  (interactive)

  ;; Clear registry
  (clrhash jf/gptel-skills--registry)

  ;; Discover markdown skills
  (let ((skill-files (jf/gptel-skills--discover))
        (md-count 0))
    (if (null skill-files)
        (message "No markdown skills found in %s" jf/gptel-skills-directory)

      ;; Parse and register each markdown skill
      (dolist (skill-file skill-files)
        (let ((metadata (jf/gptel-skills--parse-metadata skill-file)))
          (when metadata
            (let ((name (plist-get metadata :name)))
              (puthash name metadata jf/gptel-skills--registry)
              (setq md-count (1+ md-count)))))))

    ;; Try to load org-roam skills module if not already loaded
    (unless (featurep 'gptel-skills-roam)
      (let ((roam-skills-file (expand-file-name "gptel-skills-roam.el"
                                                 (file-name-directory (or load-file-name
                                                                         buffer-file-name)))))
        (when (file-exists-p roam-skills-file)
          (message "Loading org-roam skills from: %s" roam-skills-file)
          (load roam-skills-file nil t))))

    ;; Discover and register org-roam skills
    (message "Checking org-roam skills: featurep=%s enabled=%s"
             (featurep 'gptel-skills-roam)
             (if (boundp 'jf/gptel-skills-roam-enabled)
                 jf/gptel-skills-roam-enabled
               "unbound"))
    (when (and (featurep 'gptel-skills-roam)
               (boundp 'jf/gptel-skills-roam-enabled)
               jf/gptel-skills-roam-enabled)
      (let ((skill-files (jf/gptel-skills-roam--discover-files))
            (roam-count 0))
        (message "Skill files discovered: %s" skill-files)
        (dolist (file skill-files)
          (let ((metadata (jf/gptel-skills-roam--parse-file-metadata file)))
            (when metadata
              (let ((skill-name (plist-get metadata :name)))
                (message "Loaded org-roam skill: %s from %s" skill-name file)
                ;; Use skill name as key in unified registry
                (puthash skill-name metadata jf/gptel-skills--registry)
                (setq roam-count (1+ roam-count))))))
        (message "Loaded %d org-roam skill(s)" roam-count)))

    (message "Loaded %d skill(s) total (%d markdown, %d org-roam)"
             (hash-table-count jf/gptel-skills--registry)
             md-count
             (if (and (featurep 'gptel-skills-roam) jf/gptel-skills-roam-enabled)
                 (- (hash-table-count jf/gptel-skills--registry) md-count)
               0)))

  ;; Update overlays in all gptel buffers
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (bound-and-true-p gptel-mode)  ; gptel-mode is a minor mode
        (jf/gptel-skills--update-overlays)))))
#+end_src

** Describe Skill

#+begin_src emacs-lisp
(defun jf/gptel-skills-describe (skill-name)
  "Show description and metadata for SKILL-NAME."
  (interactive
   (list (completing-read "Describe skill: "
                         (hash-table-keys jf/gptel-skills--registry)
                         nil t)))
  (let ((metadata (gethash skill-name jf/gptel-skills--registry)))
    (if (not metadata)
        (message "Skill not found: %s" skill-name)
      (with-output-to-temp-buffer (format "*Skill: %s*" skill-name)
        (princ (format "Skill: %s\n\n" skill-name))
        (princ (format "Description: %s\n" (plist-get metadata :description)))
        (princ (format "Injection mode: %s\n" (plist-get metadata :injection-mode)))
        (princ (format "Path: %s\n" (plist-get metadata :path)))
        (princ (format "Loaded: %s\n" (if (plist-get metadata :loaded) "yes" "no")))
        (when (plist-get metadata :loaded)
          (princ (format "\nContent length: %d characters\n"
                        (length (plist-get metadata :content)))))))))
#+end_src

* Initialization

** Setup

#+begin_src emacs-lisp
(defun jf/gptel-skills-setup ()
  "Initialize the skills system.
Called automatically when this module is loaded."
  (when (file-directory-p (expand-file-name jf/gptel-skills-directory))
    (jf/gptel-skills-reload)

    ;; Setup hooks for existing gptel buffers
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (bound-and-true-p gptel-mode)  ; gptel-mode is a minor mode
          ;; Install buffer-local hooks
          (add-hook 'after-change-functions
                    #'jf/gptel-skills--update-overlays nil t)
          (add-hook 'completion-at-point-functions
                    #'jf/gptel-skills--completion-at-point nil t)
          ;; Initial overlay update
          (jf/gptel-skills--update-overlays))))))
#+end_src

** Hook Installation

#+begin_src emacs-lisp
;; Initialize skills and setup hooks when gptel is loaded
(with-eval-after-load 'gptel
  ;; Load skills
  (jf/gptel-skills-setup)

  ;; Add transform function to gptel
  (add-hook 'gptel-prompt-transform-functions
            #'jf/gptel-skills--transform-inject)

  ;; Add buffer-local hooks for gptel buffers
  (add-hook 'gptel-mode-hook
            (lambda ()
              ;; Update overlays on buffer changes
              (add-hook 'after-change-functions
                        #'jf/gptel-skills--update-overlays nil t)
              ;; Enable completion
              (add-hook 'completion-at-point-functions
                        #'jf/gptel-skills--completion-at-point nil t))))

;; If gptel is already loaded, initialize now
(when (featurep 'gptel)
  (jf/gptel-skills-setup))
#+end_src

* Keybindings

#+begin_src emacs-lisp
;; Define keybindings in gptel-mode
(with-eval-after-load 'gptel
  (when (boundp 'gptel-mode-map)
    (define-key gptel-mode-map (kbd "C-c @ i") 'jf/gptel-skills-insert-mention)
    (define-key gptel-mode-map (kbd "C-c @ l") 'jf/gptel-skills-list-active)
    (define-key gptel-mode-map (kbd "C-c @ c") 'jf/gptel-skills-clear-mentions)
    (define-key gptel-mode-map (kbd "C-c @ d") 'jf/gptel-skills-describe)
    (define-key gptel-mode-map (kbd "C-c @ r") 'jf/gptel-skills-reload)))
#+end_src

* Provide

#+begin_src emacs-lisp
(provide 'gptel-skills)
;;; gptel-skills.el ends here
#+end_src
